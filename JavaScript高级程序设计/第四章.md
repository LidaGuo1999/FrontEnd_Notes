## 第4章 变量、作用域和内存问题

### 4.1 基本类型和引用类型的值

js中变量可能包含两种类型值：基本类型值（简单的数据段）和引用类型值（多个值构成的对象）。5种基本数据类型都是基本类型值，而引用类型的值是保存在内存中的对象。js不允许直接访问内存中的位置，即不能直接操作对象的内存空间，因此在操作对象时实际上是操作对象的引用，而不是实际的对象。

- 基本类型的值不能添加属性，但是引用类型的值可以添加属性或者方法（类似python中的class）；

- 基本类型值在复制时，会创建一个内存独立的新值（即副本），原始变量的修改不会影响新的变量值。引用类型值在复制时，仅仅是复制了一份指针（即shallow copy），因此原始变量的修改会影响新的变量值；

- 函数参数在传递时都是按值来传递的，无论是基本类型还是引用类型。可以将函数的参数看作局部变量，不过由于引用类型的值就是指针，因此在函数内部操作引用类型参数时，外部对应的对象值也会改变。但是，如果在函数内部给引用类型参数重新赋值给另一个对象，那么外部对应变量所指向的对象不会更改，这也证明了参数是按照值来传递而非按照引用来传递；

- 用typeof操作符可以检测数据类型，而instanceof操作符可以检测引用类型的值（即到底是什么类型的对象，如Array），语法为：

  ```javascript
  result = variable instanceof constructor;
  ```

  当变量是给定引用类型的实例时，就会返回true。所有的引用类型的值都属于Object，因此constructor为Object始终为true。所有的基本类型值都不是对象，因此对它们使用instanceof操作符都会返回false；

### 4.2 执行环境及作用域

执行环境定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之相关的变量对象，环境中定义的变量和函数都保存在这个对象中，但是开发者是无法访问这个对象的。执行环境只有两种——全局和局部（函数）。

- 最外层的执行环境是全局执行环境，在web浏览器中一般就是window对象；
- 每个函数都有自己的执行环境，也存在一个函数执行的环境栈，类比内存中的函数栈；
- 代码在某个环境中执行时，为了保证对变量和函数的有序访问，会创建一个作用域链。作用域链的前端，就是当前执行的代码所在环境的变量对象。如果当前环境是函数，那么将其活动对象作为变量对象，最开始时只包含arguments一个对象（即arguments不是全局环境中的对象）。作用域链的下一个变量来自外层环境，再下一个来自再外层环境，以此类推直到全局执行环境；
- 函数的参数也被当做变量来对待，所以和其他变量的规则相同；

#### 4.2.1 延长作用域链

当执行流进入下列任何一个语句的时候，作用域链会被加长（在前端）：

- try-catch语句的catch块：会创建一个新的变量对象，其中包含了被抛出的错误对象的声明；
- with语句：会将指定的对象添加到作用域链中，而不是创建一个新的变量对象；

注意区分上述两者，with语句由于没有创建新的变量对象，因此如果在with语句内部创建新的变量，其实是将该变量创建在with的外部环境中，在with语句执行完后该新变量仍旧可以被外部环境访问到。而catch块创建了一个新的变量对象，因此在catch块中新定义的变量是无法在外部环境中访问的（在退出catch块时该变量对象就销毁了）。

#### 4.2.2 没有块级作用域

这是js与其他语言的一个很大不同点，用花括号封闭的代码块不代表一个作用域，因此没有自己的执行环境，只有全局和函数这两种才是执行环境。因此我们在if或者for循环中定义的变量，在外部仍旧可以访问到。在ES6中，使用let关键字可以定义块级作用域的变量。

- 使用var声明的变量会自动被添加到最接近的环境中。如果不使用var声明（即不声明而直接初始化变量），该变量自动添加至全局变量；
- 标识符的查询就是根据作用域链从前往后逐级查询的；

### 4.3 垃圾收集

js中内存的分配以及内存的回收是自动管理的，原理很简单：找出那些不再继续使用的变量，然后释放其所占用的内存。主要有两种策略：

- 标记清除：垃圾收集器（简称gc）在运行时首先给所有变量都打上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记。在此之后仍然有标记的变量即为准备删除的变量，因为环境中的变量已经无法访问到这些变量了；
- 引用计数：跟踪记录每个值被引用的次数，当值的引用次数为0时，说明没有办法再访问这个值，因此回收其空间。但是这有可能会导致循环引用，此时循环引用的双方的引用次数都不为0，因此都不会被回收；

虽然js中有gc自动管理内存，但是为了优化内存占用，开发者最好能通过将变量值设置为null（适用于全局变量和全局对象的属性，因为局部变量在离开执行环境是自动被解除引用）来释放引用。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。

